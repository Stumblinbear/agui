<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="getting_started.html">Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="usage/basics.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/basics/macros.html"><strong aria-hidden="true">1.1.</strong> Macros</a></li><li class="chapter-item expanded "><a href="usage/basics/widgets.html"><strong aria-hidden="true">1.2.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="usage/basics/layout.html"><strong aria-hidden="true">1.3.</strong> Layout</a></li><li class="chapter-item expanded "><a href="usage/basics/state.html"><strong aria-hidden="true">1.4.</strong> State</a></li><li class="chapter-item expanded "><a href="usage/basics/conditional-rendering.html"><strong aria-hidden="true">1.5.</strong> Conditional Rendering</a></li><li class="chapter-item expanded "><a href="usage/basics/computed.html"><strong aria-hidden="true">1.6.</strong> Computed Values</a></li><li class="chapter-item expanded "><a href="usage/basics/limiting-rebuilds.html"><strong aria-hidden="true">1.7.</strong> Limiting Rebuilds</a></li></ol></li><li class="chapter-item expanded "><a href="usage/advanced.html"><strong aria-hidden="true">2.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/advanced/clipping.html"><strong aria-hidden="true">2.1.</strong> Clipping</a></li><li class="chapter-item expanded "><a href="usage/advanced/events.html"><strong aria-hidden="true">2.2.</strong> Events</a></li><li class="chapter-item expanded "><a href="usage/advanced/keys.html"><strong aria-hidden="true">2.3.</strong> Keys</a></li></ol></li><li class="chapter-item expanded "><a href="usage/plugins.html"><strong aria-hidden="true">3.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/plugins/fonts.html"><strong aria-hidden="true">3.1.</strong> Fonts</a></li><li class="chapter-item expanded "><a href="usage/plugins/themes.html"><strong aria-hidden="true">3.2.</strong> Themes</a></li><li class="chapter-item expanded "><a href="usage/plugins/providers_and_consumers.html"><strong aria-hidden="true">3.3.</strong> Providers &amp; Consumers</a></li><li class="chapter-item expanded "><a href="usage/plugins/animations.html"><strong aria-hidden="true">3.4.</strong> Animations</a></li><li class="chapter-item expanded "><a href="usage/plugins/mouse_and_keyboard.html"><strong aria-hidden="true">3.5.</strong> Mouse &amp; Keyboard</a></li><li class="chapter-item expanded "><a href="usage/plugins/hovering.html"><strong aria-hidden="true">3.6.</strong> Hovering</a></li><li class="chapter-item expanded "><a href="usage/plugins/writing_a_plugin.html"><strong aria-hidden="true">3.7.</strong> Writing your Own</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Widget Reference</li><li class="chapter-item expanded "><a href="widgets/primitives.html"><strong aria-hidden="true">4.</strong> Primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="widgets/primitives/layout.html"><strong aria-hidden="true">4.1.</strong> Layout</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="widgets/primitives/row.html"><strong aria-hidden="true">4.1.1.</strong> Row</a></li><li class="chapter-item expanded "><a href="widgets/primitives/column.html"><strong aria-hidden="true">4.1.2.</strong> Column</a></li><li class="chapter-item expanded "><a href="widgets/primitives/spadding.html"><strong aria-hidden="true">4.1.3.</strong> Padding</a></li><li class="chapter-item expanded "><a href="widgets/primitives/sspacing.html"><strong aria-hidden="true">4.1.4.</strong> Spacing</a></li></ol></li><li class="chapter-item expanded "><a href="widgets/primitives/drawable.html"><strong aria-hidden="true">4.2.</strong> Drawable</a></li><li class="chapter-item expanded "><a href="widgets/primitives/text.html"><strong aria-hidden="true">4.3.</strong> Text</a></li></ol></li><li class="chapter-item expanded "><a href="widgets/widgets.html"><strong aria-hidden="true">5.</strong> Widgets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="widgets/widgets/app.html"><strong aria-hidden="true">5.1.</strong> App</a></li><li class="chapter-item expanded "><a href="widgets/widgets/button.html"><strong aria-hidden="true">5.2.</strong> Button</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Integrations</li><li class="chapter-item expanded "><a href="integrations/how_they_work.html"><strong aria-hidden="true">6.</strong> How they work</a></li><li class="chapter-item expanded "><a href="integrations/writing_your_own.html"><strong aria-hidden="true">7.</strong> Writing your own</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrations/writing_your_own/guarantees.html"><strong aria-hidden="true">7.1.</strong> Guarantees</a></li><li class="chapter-item expanded "><a href="integrations/writing_your_own/layers.html"><strong aria-hidden="true">7.2.</strong> Layers</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Cookbook</li><li class="chapter-item expanded "><a href="cookbook/title_screen.html"><strong aria-hidden="true">8.</strong> Title Screen</a></li><li class="chapter-item expanded "><a href="cookbook/settings.html"><strong aria-hidden="true">9.</strong> Settings</a></li><li class="chapter-item expanded "><a href="cookbook/scroll_view.html"><strong aria-hidden="true">10.</strong> Scroll View</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Agui</strong> is a reactive UI library, built in pure Rust, made for pure Rust. It's inspired by Flutter and other reactive UI libraries, and almost more importantly: it's renderer-agnostic. There are a few basic concepts to learn, but if you come from a background of Flutter, React, Vue, or other similar libraries, you'll feel right at home.</p>
<h2 id="stability-warning"><a class="header" href="#stability-warning">Stability Warning</a></h2>
<p>While the core of <code>Agui</code> is mostly stable, it is still very much in its infancy. The API may change, and optimizations still need to be done, especially when it comes to talking to the render integrations, and the integrations themselves. We are still finding our way, and that will take time. That said: it works. If you need a feature that doesn't exist, feel free to contribute or make a plugin!</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Agui is free and open source. You can find the source code on <a href="https://github.com/stumblinbear/agui">GitHub</a>, issues can be posted on the <a href="https://github.com/stumblinbear/agui/issues">GitHub issue tracker</a>, with feature requests and questions directed to <a href="https://github.com/stumblinbear/agui/discussions">Github discussions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p><code>agui</code> is available on <a href="https://crates.io/crates/agui">crates.io</a>, Rust's official package repository. Just add this to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
agui = &quot;0.3&quot; # ensure this is the latest version
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello, world!</a></h2>
<p>First, you need to select your integration. To get started quickly, we're going to run with <code>agui_agpu</code> since it's the most feature complete. <code>agpu</code> is an abstraction over <code>wgpu</code> to make it easier to use, so it's effectively a <code>wgpu</code> integration.</p>
<p>The smallest program you can start up to render something can be found in <code>agui_agpu/examples/hello_world.rs</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">fn main() -&gt; Result&lt;(), agpu::BoxError&gt; {
</span>    let program = agpu::GpuProgram::builder(&quot;agui: Hello, world!&quot;)
        // The integration requires a few GPU features to be enabled
        .with_gpu_features(
                Features::TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
                | Features::VERTEX_WRITABLE_STORAGE,
        )
        .build()?;

    // Create a UI with the default render passes
    let mut ui = UI::with_default(&amp;program);

    // Import a font so we can render text
    let deja_vu_sans = ui.load_font_bytes(include_bytes!(&quot;./fonts/DejaVuSans.ttf&quot;));

    // Set the root node of the UI
    ui.set_root(build! {
        App {
            child: Text::is(deja_vu_sans, 32.0, &quot;Hello, world!&quot;.into())
        }
    });

    // Start the update loop
    ui.run(program)
<span class="boring">}
</span></code></pre>
<p>There's a little initial setup to create the GpuProgram and UI, most of what we care about is loading the font and <code>ui.set_root</code>. The <code>build!</code> macro will be <a href="usage/basics/macros.html">explained soon</a>. How fonts work will be explained a bit futher in a <a href="usage/plugins/fonts.html">later section</a>.</p>
<p>With the above code, you should be left with something like this:</p>
<p><img src="assets/hello_world.png" alt="Hello World" /></p>
<p>Truly remarkable.</p>
<p>Yeah, it's not much to look at, but we'll build on this in future sections to make more elaborate (and reactive!) interfaces.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>If you come from a background of Flutter or React/Vue, most of this should be familiar to you. However, I'll explain for those that have never heard of them.</p>
<p>User interfaces are inheritly complex and must be orchestrated properly to keep the visuals in line with the actual state of the program. Generally, this is a complex problem, and many issues can (and will) occur if you leave this &quot;refreshing&quot; up to the actual logic of your code. What a reactive UI library does is abstract your interface a bit to provide automatic updates to it whenever your state changes, ensuring your visuals and your state are always in sync.</p>
<p>However, with this ~magic~ comes additional considerations to your code. When state changes, all widgets listening to that state are updated in the UI tree. This means that you need to put some thought into limiting these rebuilds to as small of a piece of the tree as you can manage. While <code>agui</code> manages to reduce rebuilds where it can, it's not a magic bullet; we forgo tree-diffing for performance reasons, and to prevent problematic edge cases.</p>
<p>Hopefully that wasn't too much jargon for you. Just in case, here's a tl;dr: <strong>UIs are complex, use <code>agui</code> to make them less of a pain to handle.</strong></p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<ul>
<li><strong>Widget</strong>: A user interface is built on Widgets, which can be anything from pure data, to managers, to elements drawn on screen. <code>agui</code> makes little distinction between them.</li>
<li><strong>Layout</strong>: <code>agui</code> leverages <a href="https://github.com/geom3trik/morphorm">morphorm</a> for its layout system, which itself is modeled after the <a href="https://subformapp.com/articles/why-not-flexbox/">subform layout system</a>.</li>
<li><strong>State</strong>: At its core, <code>agui</code> is a state manager. It takes in your application state, and manages its lifecycle end-to-end, listening for changes and updating your widgets as necessary.</li>
<li><strong>Global</strong>: A global is state that exists as a singleton within your application. All widgets will read and write the same data.</li>
<li><strong>Plugin</strong>: A plugin is essentially a singleton widget that does not exist in the tree. They are often used to manage a global state that other widgets may listen to.</li>
<li><strong>Computed Functions</strong>: A function returns a value, only causing updates to the widget if the returned value changes.</li>
<li><strong>Key</strong>: A key is a way to instruct <code>agui</code> to cache a widget between rebuilds.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>Before we get too much further, you must understand some of the macros we'll be using in this guide. There are two main ones that <code>agui</code> provides.</p>
<h2 id="the-build-macro"><a class="header" href="#the-build-macro">The <code>build!</code> macro</a></h2>
<p>This is a convenience macro. It's not technically required (in fact it's quite easy to never use it) but it makes our life a bit easier. In exchange for some black-box magic, you get better maintainability and better looking code.</p>
<pre><code class="language-rust noplaypen">// Before:
fn build(&amp;self, ctx: &amp;WidgetContext) -&gt; BuildResult {
    BuildResult::One(
        Button {
            child: Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 64.0, height 32.0 },
                    ..Layout::default()
                }.into(),
                ..Drawable::default()
            },
            ..Button::default()
        }.into()
    )
}

// After:
fn build(&amp;self, ctx: &amp;WidgetContext) -&gt; BuildResult {
    build!{
        Button {
            child: Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 64.0, height 32.0 }
                }
            }
        }
    }
}
</code></pre>
<p>Doesn't that look nice? Essentially all it is doing is adding <code>.into()</code> to your blocks and adding <code>Default::default()</code> to your structs. Note that it does make many assumptions, notably that every struct will <code>#[derive(Default)]</code>.</p>
<h2 id="functional_widget"><a class="header" href="#functional_widget">#[functional_widget]</a></h2>
<p>The vast majority of widgets are simple fields followed by a single <code>build()</code> function. This means we have room for simplification: why not just make our function our widget? Well alright then. Ask and ye shall receive.</p>
<pre><code class="language-rust noplaypen">#[functional_widget]
// The macro will turn `snake_case` into `PascalCase` for the widget name
fn example_widget(ctx: &amp;WidgetContext, layout: Ref&lt;Layout&gt;, child: WidgetRef) -&gt; BuildResult {
    ctx.set_layout(layout);
    
    build!{
        Button {
            child: child
        }
    }
}
</code></pre>
<p>See? Instead of establishing a struct called <code>ExampleWidget</code> with the fields of <code>layout</code> and <code>child</code>, we can just make a function and tag it with the macro. The <code>ctx: &amp;WidgetContext</code> parameter is required, and any following arguments are added as a struct field. Of course, all of this comes with assumptions and potential overhead. Any field used here must implement <code>Default + Clone</code> in some form or another, so that the widget may call the <code>example_widget</code> function without issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>A widget is anything that <em>exists</em> in the UI tree. It could be a visual element, a management system, or just plain-ol-data. You can find a full list of them in the <a href="usage/basics/../../widgets/widgets.html">Widget Reference</a>.</p>
<h2 id="primitives"><a class="header" href="#primitives">Primitives</a></h2>
<p><code>agui</code> comes with a set of extremely simple widgets that are referred to as Primitives. These generally cover the most basic renderable ~things~ or other extremely useful widgets that don't offer much opinionated functionality, but are still very useful. Render integrations hook into these to draw the actual visual elements, giving a very small barrier to entry to have all features of <code>agui</code>. You can find a full list of them in the <a href="usage/basics/../../widgets/primitives.html">Primitive Widget Reference</a>.</p>
<h2 id="creating-a-widget"><a class="header" href="#creating-a-widget">Creating a Widget</a></h2>
<p>A widget consists of two things: its settings and a build function. In Rust, this is just a <code>struct</code> with an <code>impl WidgetBuilder</code>. We're going to start simple, with a basic box on the screen:</p>
<pre><code class="language-rust noplaypen">pub struct Button { }

impl WidgetBuilder for Button {
    fn build(&amp;self, ctx: &amp;WidgetContext) -&gt; BuildResult {
        BuildResult::Empty
    }
}
</code></pre>
<p>If you run this... Nothing will happen. Which makes sense, as we don't have any widgets that actually render anything. Lets add one and give it a size.</p>
<pre><code class="language-rust noplaypen">impl WidgetBuilder for Button {
    fn build(&amp;self, ctx: &amp;WidgetContext) -&gt; BuildResult {
        build! {
            Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 64.0, height 32.0 }
                }
            }
        }
    }
}
</code></pre>
<p>This should render a rectangle on screen that's 64x32 pixels. Pretty swick, if I do say so myself. <code>Drawable</code> is the most important primitive widget we have, as it's used to tell the renderer to actually draw something on screen. Without it, we have nothing. As long as you stick to <code>Drawable</code>, your widget should render exactly the same no matter where it's running.</p>
<p>One important thing to note is clipping is not enabled by default. We'll cover why that is and the implications of that in a <a href="usage/basics/../advanced/clipping.html">later section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout"><a class="header" href="#layout">Layout</a></h1>
<p><code>agui</code> leverages <a href="https://github.com/geom3trik/morphorm">morphorm</a> for its layout system, which itself is modeled after the <a href="https://subformapp.com/articles/why-not-flexbox/">subform layout system</a>. While we go into some detail here, it's recommended to do some research into those as well until this page is fleshed out a bit more.</p>
<h2 id="why-subform-why-not-flexbox"><a class="header" href="#why-subform-why-not-flexbox">Why subform? Why not flexbox?</a></h2>
<p>Because, frankly, flexbox is confusing. We need something simpler, that doesn't interact with itself in invisible ways or bring in new concepts such as <code>align-items</code>, <code>justify-content</code>, or <code>align-self</code>. According to Subform themselves, the tl;dr is:</p>
<blockquote>
<ul>
<li>All elements have a horizontal and vertical axis, each of which consists of space before, size, and space after.</li>
<li>Elements either control their own position (“self-directed”, akin to CSS absolute positioning) or are positioned by their parent (parent-directed).</li>
<li>Parents can position their parent-directed children in a vertical stack, horizontal stack, or grid.</li>
<li>The same units—pixels, percentages (of the parent size), and stretch (akin to flex, proportionally dividing up available space)—are used everywhere, with minimum and maximum constraints as part of the unit.</li>
</ul>
</blockquote>
<p>At its most basic level, your layouts are just rows and columns of widgets, each of which may contain more rows and columns of widgets. Beyond that, sizes of your widgets can be pixels, a percentage of the parent, or stretch to fill. That's it. Stupid simple.</p>
<h2 id="how-do-i-use-it"><a class="header" href="#how-do-i-use-it">How do I use it?</a></h2>
<p>There are some primitive widgets that make the layout system easier to grok. <code>Column</code>, <code>Row</code>, <code>Grid</code>, <code>Padding</code>, and <code>Spacing</code>, each of which simply abstract out the layout. While you could use <code>ctx.set_layout</code> for each widget yourself, it's recommended to use these widgets instead, as it makes your widgets simpler and more reusable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state"><a class="header" href="#state">State</a></h1>
<p>Widgets may contain their own, self contained state, which persists across rebuilds (usually—more on that in a minute). Whenever the state changes, the widget's <code>build()</code> function will be re-invoked, and its children will be rebuilt. This is your main tool for implementing a user interface that can react to user events. Lets write up a quick counter example to demonstrate this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Requires the `HoverPlugin` for the `Button` to function properly, so
// make sure you call `ui.init_plugin(HoveringPlugin::default);`

#[functional_widget]
fn counter_widget(ctx: &amp;WidgetContext, font: FontId) -&gt; BuildResult {
    let num = ctx.use_state(|| 0);

    build! {
        Column {
            children: [
                Text::is(font, 32.0, format!(&quot;clicked: {} times&quot;, num.read())),
                Button {
                    child: Padding {
                        padding: Margin::All(10.0.into()),
                        child: Text::is(font, 32.0, &quot;A Button&quot;.into())
                    },
                    on_pressed: Callback::from(move |()| {
                        *num.write() += 1;
                    })
                }
            ]
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Any time you use <code>num.write()</code>, it will cause any listening widgets to be rebuilt on the next update, so ensure you only call it when you <em>actually</em> change something. The first time <code>ctx.use_state(|| 0)</code> is used, the closure within the method is called to initialize the state. In this case, it will be initialized to zero. On subsequent rebuilds of the widget, the previous state that it was in will be persisted. However, this only applies if the parent of the widget is not rebuilt.</p>
<p>If you want to create state, but not listen to changes to it, you can instead use <code>ctx.init_state(|| 0)</code>. This is useful for widgets that manage state that children respond to, but state that itself doesn't react to. If you were to use that, instead, the state will have changed internally, but you wouldn't see any change to the UI.</p>
<h2 id="globals"><a class="header" href="#globals">Globals</a></h2>
<p>Global acts much the same way as state, but it exists once in your application and is shared amongst all widgets, no matter how deep they are in your tree.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[functional_widget]
fn widget_with_global(ctx: &amp;WidgetContext) -&gt; BuildResult {
    let state = ctx.use_global(|| 0);

    build! {
        Drawable {
            layout: Layout {
                sizing: Sizing::Set { width: 64.0, height 32.0 }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, <code>use_global</code> will fetch the global state or initialize it to zero if it does not already exist.</p>
<h2 id="parental-rebuilds"><a class="header" href="#parental-rebuilds">Parental rebuilds</a></h2>
<p>When a widget is rebuilt, its state is persisted. However, any children it has will be reinitialized, meaning <em>their</em> state will be destroyed. This means you need to be careful in how you structure your interface to reduce rebuilds, and to work around this limitation. For more information on this, you can see <a href="usage/basics/limiting-rebuilds.html">Limiting Rebuilds</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-rendering"><a class="header" href="#conditional-rendering">Conditional Rendering</a></h1>
<p>Often you'll want to render a widget conditionally. Thankfully, this is extremely straightforward to do, as the <code>build!</code> macro supports pretty much all Rust syntax.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[functional_widget]
fn conditional_widget(ctx: &amp;WidgetContext, toggle_something: bool) -&gt; BuildResult {
    build!{
        if toggle_something {
            Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 64.0, height 32.0 }
                }
            }
        }else{
            Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 32.0, height 64.0 }
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>To render based on state is just as easy, just read the state and check against it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[functional_widget]
fn conditional_widget(ctx: &amp;WidgetContext) -&gt; BuildResult {
    let some_state = ctx.use_state(|| true);

    build! {
        if *some_state.read() {
            Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 64.0, height 32.0 }
                }
            }
        }else{
            Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 32.0, height 64.0 }
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computed-values"><a class="header" href="#computed-values">Computed Values</a></h1>
<p>Computed functions are an extremely useful construct. They can listen to state and react to it, but will only cause the widget they're defined in to rebuild if their return value changes. Instead of implementing an event listener system, we use computed functions to achieve the same effect.</p>
<p>To demonstrate computed functions, we'll check if the user is currently hovering over the widget by utilizing the <code>HoverPlugin</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[functional_widget]
fn hovering_widget(ctx: &amp;WidgetContext) -&gt; BuildResult {
    let is_hovering = ctx.computed(|ctx| {
        if let Some(hovering) = ctx.try_use_global::&lt;Hovering&gt;() {
            if hovering.read().is_hovering(ctx) {
                true
            }
        }

        false
    });

    build! {
        if is_hovering {
            Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 64.0, height 32.0 }
                }
            }
        }else{
            Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 32.0, height 64.0 }
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this case, the computed function will be called whenever the <code>Hovering</code> global state is updated, but will only mark the widget for rebuild when it returns a different value. In this case, it will only rebuild when it goes from a non-hover state to a hover state and vice versa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limiting-rebuilds"><a class="header" href="#limiting-rebuilds">Limiting Rebuilds</a></h1>
<p>Rebuilds are at the heart of how <code>agui</code> works. Whenever state changes, the widgets in the tree that may change are updated. However, this is a very naïve system and much of the responsibility for limiting these rebuilds is up to the developer (you). We'll go over the problem, and devise a few solutions for it, however ultimately the decision is up to you.</p>
<h2 id="builders"><a class="header" href="#builders">Builders</a></h2>
<p>Builders are essentially closure-derived widgets. You can create these ad-hoc to limit the scope of rebuilds to a sub-tree of widgets, because they're essentially parent-widgets themselves with their own <code>WidgetContext</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[functional_widget]
fn widget_with_builder(ctx: &amp;WidgetContext) -&gt; BuildResult {
    build! {
        Builder::new(move |ctx| {
            // `ctx` is a new `WidgetContext` which will not affect the parent widget

            let state = ctx.use_state(|| 0);

            build! {
                Drawable {
                    layout: Layout {
                        sizing: Sizing::Set { width: 64.0, height 32.0 }
                    }
                }
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="globals-1"><a class="header" href="#globals-1">Globals</a></h2>
<p>Another option is utilizing global state.  You can create state, then create sub-widgets which listen to that state, resulting in potentially fewer rebuilds of your application with little effort. However, this has the effect of making it difficult to grok exactly what your application is doing if used incorrectly, and potentially makes limiting the scope of rebuilds more troublesome as your application grows. <a href="usage/basics/state.html">You can read more about it here.</a>.</p>
<h2 id="providers-and-consumers"><a class="header" href="#providers-and-consumers">Providers and Consumers</a></h2>
<p>Instead of global state, you can use <a href="usage/basics/../plugins/providers_and_consumers.html">Providers</a>. This is an optional plugin which makes state available to its subtree of widgets, however it's not free. Whenever a child needs to access the state, it needs to traverse the tree to find a parent which is providing that state. This is <em>often</em> negligable, but as your application grows it may become more pronounced if the children that use the state are deeper in the tree.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced"><a class="header" href="#advanced">Advanced</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clipping"><a class="header" href="#clipping">Clipping</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keys"><a class="header" href="#keys">Keys</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fonts"><a class="header" href="#fonts">Fonts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="themes"><a class="header" href="#themes">Themes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="providers--consumers"><a class="header" href="#providers--consumers">Providers &amp; Consumers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animations"><a class="header" href="#animations">Animations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mouse--keyboard"><a class="header" href="#mouse--keyboard">Mouse &amp; Keyboard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hovering"><a class="header" href="#hovering">Hovering</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-your-own"><a class="header" href="#writing-your-own">Writing your Own</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitives-1"><a class="header" href="#primitives-1">Primitives</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout-1"><a class="header" href="#layout-1">Layout</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="row"><a class="header" href="#row">Row</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="column"><a class="header" href="#column">Column</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="padding"><a class="header" href="#padding">Padding</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spacing"><a class="header" href="#spacing">Spacing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawable"><a class="header" href="#drawable">Drawable</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets-1"><a class="header" href="#widgets-1">Widgets</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app"><a class="header" href="#app">App</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="button"><a class="header" href="#button">Button</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-they-work"><a class="header" href="#how-they-work">How they work</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-your-own-1"><a class="header" href="#writing-your-own-1">Writing your own</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guarantees"><a class="header" href="#guarantees">Guarantees</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layers"><a class="header" href="#layers">Layers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="title-screen"><a class="header" href="#title-screen">Title Screen</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings"><a class="header" href="#settings">Settings</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-view"><a class="header" href="#scroll-view">Scroll View</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
