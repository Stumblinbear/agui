<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="getting_started.html">Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Usage</li><li class="chapter-item expanded "><a href="usage/macros.html"><strong aria-hidden="true">1.</strong> Macros</a></li><li class="chapter-item expanded "><a href="usage/widgets.html"><strong aria-hidden="true">2.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="usage/layout.html"><strong aria-hidden="true">3.</strong> Layout</a></li><li class="chapter-item expanded "><a href="usage/state.html"><strong aria-hidden="true">4.</strong> State</a></li><li class="chapter-item expanded "><a href="usage/fonts.html"><strong aria-hidden="true">5.</strong> Fonts</a></li><li class="chapter-item expanded "><a href="usage/clipping.html"><strong aria-hidden="true">6.</strong> Clipping</a></li><li class="chapter-item expanded "><a href="usage/keyed-widgets.html"><strong aria-hidden="true">7.</strong> Keyed Widgets</a></li><li class="chapter-item expanded "><a href="usage/computed.html"><strong aria-hidden="true">8.</strong> Computed Values</a></li><li class="chapter-item expanded "><a href="usage/limiting-rebuilds.html"><strong aria-hidden="true">9.</strong> Limiting Rebuilds</a></li><li class="chapter-item expanded affix "><li class="part-title">Plugins</li><li class="chapter-item expanded "><a href="plugins/providers_and_consumers.html"><strong aria-hidden="true">10.</strong> Providers &amp; Consumers</a></li><li class="chapter-item expanded "><a href="plugins/hovering.html"><strong aria-hidden="true">11.</strong> Hovering</a></li><li class="chapter-item expanded "><a href="plugins/animations.html"><strong aria-hidden="true">12.</strong> Animations</a></li><li class="chapter-item expanded "><a href="plugins/writing_a_plugin.html"><strong aria-hidden="true">13.</strong> Writing your Own</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/primitives.html"><strong aria-hidden="true">14.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="reference/widgets.html"><strong aria-hidden="true">15.</strong> Widgets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/widgets/app.html"><strong aria-hidden="true">15.1.</strong> App</a></li><li class="chapter-item expanded "><a href="reference/widgets/button.html"><strong aria-hidden="true">15.2.</strong> Button</a></li></ol></li><li class="chapter-item expanded "><a href="reference/globals.html"><strong aria-hidden="true">16.</strong> Globals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/globals/mouse.html"><strong aria-hidden="true">16.1.</strong> Mouse</a></li><li class="chapter-item expanded "><a href="reference/globals/keyboard.html"><strong aria-hidden="true">16.2.</strong> Keyboard</a></li><li class="chapter-item expanded "><a href="reference/globals/themes.html"><strong aria-hidden="true">16.3.</strong> Themes</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Integrations</li><li class="chapter-item expanded "><a href="integrations/how_they_work.html"><strong aria-hidden="true">17.</strong> How they work</a></li><li class="chapter-item expanded "><a href="integrations/writing_your_own.html"><strong aria-hidden="true">18.</strong> Writing your own</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrations/writing_your_own/guarantees.html"><strong aria-hidden="true">18.1.</strong> Guarantees</a></li><li class="chapter-item expanded "><a href="integrations/writing_your_own/layers.html"><strong aria-hidden="true">18.2.</strong> Layers</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Cookbook</li><li class="chapter-item expanded "><a href="cookbook/title_screen.html"><strong aria-hidden="true">19.</strong> Title Screen</a></li><li class="chapter-item expanded "><a href="cookbook/settings.html"><strong aria-hidden="true">20.</strong> Settings</a></li><li class="chapter-item expanded "><a href="cookbook/scroll_view.html"><strong aria-hidden="true">21.</strong> Scroll View</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Agui</strong> is a reactive UI library, built in pure Rust, made for pure Rust. It's inspired by Flutter and other reactive UI libraries, and almost more importantly: it's renderer-agnostic.  There are a few basic concepts to learn, but if you come from a background of Flutter, React, Vue, or other similar libraries, you'll feel right at home. However, I'll explain for those that have never heard of them.</p>
<p>User interfaces are inheritly complex and must be orchestrated properly to keep the visuals in line with the actual state of the program. Generally, this is a complex problem, and many issues can (and will) occur if you leave this &quot;refreshing&quot; up to the actual logic of your code. What a reactive UI library does is abstract your interface a bit to provide automatic updates to it whenever your state changes, ensuring your visuals and your state are always in sync.</p>
<p>However, with this ~magic~ comes additional considerations to your code. When state changes, all widgets listening to that state are updated in the UI tree. This means that you need to put some thought into limiting these rebuilds to as small of a piece of the tree as you can manage. While <code>agui</code> manages to reduce rebuilds where it can, it's not a magic bullet; we forgo tree-diffing for performance reasons, and to prevent problematic edge cases.</p>
<p>Hopefully that wasn't too much jargon for you. Just in case, here's a tl;dr: <strong>UIs are complex, use <code>agui</code> to make them less of a pain to handle.</strong></p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<ul>
<li><strong>Widget</strong>: A user interface is built on Widgets, which can be anything from pure data, to managers, to elements drawn on screen. <code>agui</code> makes little distinction between them.</li>
<li><strong>Layout</strong>: <code>agui</code> leverages <a href="https://github.com/geom3trik/morphorm">morphorm</a> for its layout system, which itself is modeled after the <a href="https://subformapp.com/articles/why-not-flexbox/">subform layout system</a>.</li>
<li><strong>State</strong>: At its core, <code>agui</code> is a state manager. It takes in your application state, and manages its lifecycle end-to-end, listening for changes and updating your widgets as necessary.</li>
<li><strong>Global</strong>: A global is state that exists as a singleton within your application. All widgets will read and write the same data.</li>
<li><strong>Plugin</strong>: A plugin is essentially a singleton widget that does not exist in the tree. They are often used to manage one (or more) globals that other widgets may listen to.</li>
<li><strong>Computed Values</strong>: A function that returns a value, only causing updates to the widget if the returned value changes.</li>
<li><strong>Key</strong>: A key is a way to instruct <code>agui</code> to cache a widget between rebuilds.</li>
</ul>
<h2 id="stability-warning"><a class="header" href="#stability-warning">Stability Warning</a></h2>
<p>While the core of <code>Agui</code> is mostly stable, it is still very much in its infancy. The API may change, and optimizations still need to be done, especially when it comes to talking to the render integrations, and the integrations themselves. We are still finding our way, and that will take time. That said: it works. If you need a feature that doesn't exist, feel free to contribute or make a plugin!</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Agui is free and open source. You can find the source code on <a href="https://github.com/stumblinbear/agui">GitHub</a>, issues can be posted on the <a href="https://github.com/stumblinbear/agui/issues">GitHub issue tracker</a>, with feature requests and questions directed to <a href="https://github.com/stumblinbear/agui/discussions">Github discussions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p><code>agui</code> is available on <a href="https://crates.io/crates/agui">crates.io</a>, Rust's official package repository. Just add this to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
agui = &quot;0.3&quot; # ensure this is the latest version
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello, world!</a></h2>
<p>First, you need to select your integration. To get started quickly, we're going to run with <code>agui_agpu</code> since it's the most feature complete. <code>agpu</code> is an abstraction over <code>wgpu</code> to make it easier to use, so it's effectively a <code>wgpu</code> integration.</p>
<p>The smallest program you can start up to render something can be found in <code>agui_agpu/examples/hello_world.rs</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">fn main() -&gt; Result&lt;(), agpu::BoxError&gt; {
</span>    let program = agpu::GpuProgram::builder(&quot;agui: hello_world&quot;)
        // The integration requires a few GPU features to be enabled
        .with_gpu_features(
                Features::TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
                | Features::VERTEX_WRITABLE_STORAGE,
        )
        .build()?;

    // Create a UI with the default render passes
    let mut ui = UI::with_default(&amp;program);

    // Import a font so we can render text
    let deja_vu_sans = ui.load_font_bytes(include_bytes!(&quot;./fonts/DejaVuSans.ttf&quot;));

    // Set the root node of the UI
    ui.set_root(build! {
        App {
            child: Text::is(deja_vu_sans, 32.0, &quot;Hello, world!&quot;.into())
        }
    });

    // Start the update loop
    ui.run(program)
<span class="boring">}
</span></code></pre>
<p>There's a little initial setup to create the GpuProgram and UI, most of what we care about is loading the font and <code>ui.set_root</code>. The <code>build!</code> macro will be <a href="usage/macros.html">explained soon</a>. How fonts work will be explained a bit futher in a <a href="usage/fonts.html">later section</a>.</p>
<p>With the above code, you should be left with something like this:</p>
<p><img src="assets/hello_world.png" alt="Hello World" /></p>
<p>Truly remarkable.</p>
<p>Yeah, it's not much to look at, but we'll build on this in future sections to make more elaborate (and reactive!) interfaces.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>Before we get too much further, you must understand some of the macros we'll be using in this guide. There are two main ones that <code>agui</code> provides.</p>
<h2 id="the-build-macro"><a class="header" href="#the-build-macro">The <code>build!</code> macro</a></h2>
<p>This is a convenience macro. It's not technically required (in fact it's quite easy to never use it) but it makes our life a bit easier. In exchange for some black-box magic, you get better maintainability and better looking code. It supports pretty much all of Rust syntax, so you can embed logic (such as <code>if</code> or <code>match</code> statements) within it as normal.</p>
<pre><code class="language-rust noplaypen">// Before:
fn build(&amp;self, ctx: &amp;WidgetContext) -&gt; BuildResult {
    BuildResult::One(
        Button {
            child: Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 64.0, height 32.0 },
                    ..Layout::default()
                }.into(),
                ..Drawable::default()
            },
            ..Button::default()
        }.into()
    )
}

// After:
fn build(&amp;self, ctx: &amp;WidgetContext) -&gt; BuildResult {
    build!{
        Button {
            child: Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 64.0, height 32.0 }
                }
            }
        }
    }
}
</code></pre>
<p>Doesn't that look nice? Essentially all it is doing is adding <code>.into()</code> to your blocks and adding <code>Default::default()</code> to your structs. Note that it does make many assumptions, notably that every struct will <code>#[derive(Default)]</code>.</p>
<h2 id="functional_widget"><a class="header" href="#functional_widget">#[functional_widget]</a></h2>
<p>The vast majority of widgets are simple fields followed by a single <code>build()</code> function. This means we have room for simplification: why not just make our function our widget? Well alright then. Ask and ye shall receive.</p>
<pre><code class="language-rust noplaypen">#[functional_widget]
// The macro will turn `snake_case` into `PascalCase` for the widget name
fn example_widget(ctx: &amp;WidgetContext, layout: Ref&lt;Layout&gt;, child: WidgetRef) -&gt; BuildResult {
    ctx.set_layout(layout);
    
    build!{
        Button {
            child: child
        }
    }
}
</code></pre>
<p>See? Instead of establishing a struct called <code>ExampleWidget</code> with the fields of <code>layout</code> and <code>child</code>, we can just make a function and tag it with the macro. The <code>ctx: &amp;WidgetContext</code> parameter is required, and any following arguments are added as a struct field. Of course, all of this comes with assumptions and potential overhead. Any field used here must implement <code>Default + Clone</code> in some form or another, so that the widget may call the <code>example_widget</code> function without issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>A widget is anything that <em>exists</em> in the UI tree. It could be a visual element, a management system, or just plain-ol-data. You can find a full list of them in the <a href="usage/../widgets/widgets.html">Widget Reference</a>.</p>
<h2 id="primitives"><a class="header" href="#primitives">Primitives</a></h2>
<p><code>agui</code> comes with a set of extremely simple widgets that are referred to as Primitives. These generally cover the most basic renderable ~things~ or other extremely useful widgets that don't offer much opinionated functionality, but are still very useful. Render integrations hook into these to draw the actual visual elements, giving a very small barrier to entry to have all features of <code>agui</code>. You can find a full list of them in the <a href="usage/../widgets/primitives.html">Primitive Widget Reference</a>.</p>
<h2 id="creating-a-widget"><a class="header" href="#creating-a-widget">Creating a Widget</a></h2>
<p>A widget consists of two things: its settings and a build function. In Rust, this is just a <code>struct</code> with an <code>impl WidgetBuilder</code>. We're going to start simple, with a basic box on the screen:</p>
<pre><code class="language-rust noplaypen">pub struct Button { }

impl WidgetBuilder for Button {
    fn build(&amp;self, ctx: &amp;WidgetContext) -&gt; BuildResult {
        BuildResult::None
    }
}
</code></pre>
<p>If you run this... Nothing will happen. Which makes sense, as we don't have any widgets that actually render anything. Lets add one and give it a size.</p>
<pre><code class="language-rust noplaypen">impl WidgetBuilder for Button {
    fn build(&amp;self, ctx: &amp;WidgetContext) -&gt; BuildResult {
        build! {
            Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 64.0, height 32.0 }
                }
            }
        }
    }
}
</code></pre>
<p>This should render a rectangle on screen that's 64x32 pixels. Pretty swick, if I do say so myself. <code>Drawable</code> is the most important primitive widget we have, as it's used to tell the renderer to actually draw something on screen. Without it, we have nothing. As long as you stick to <code>Drawable</code>, your widget should render exactly the same no matter what integration it is used in.</p>
<p>One important thing to note is clipping is not enabled by default. We'll cover why that is and the implications of that in a <a href="usage/./clipping.html">later section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layout"><a class="header" href="#layout">Layout</a></h1>
<p><code>agui</code> leverages <a href="https://github.com/geom3trik/morphorm">morphorm</a> for its layout system, which itself is modeled after the <a href="https://subformapp.com/articles/why-not-flexbox/">subform layout system</a>. While we go into some detail here, it's recommended to do some research into those as well until this page is fleshed out a bit more.</p>
<h2 id="why-subform-why-not-flexbox"><a class="header" href="#why-subform-why-not-flexbox">Why subform? Why not flexbox?</a></h2>
<p>Because, frankly, flexbox is confusing. We need something simpler, that doesn't interact with itself in invisible ways or bring in new concepts such as <code>align-items</code>, <code>justify-content</code>, or <code>align-self</code>. According to Subform themselves, the tl;dr is:</p>
<blockquote>
<ul>
<li>All elements have a horizontal and vertical axis, each of which consists of space before, size, and space after.</li>
<li>Elements either control their own position (“self-directed”, akin to CSS absolute positioning) or are positioned by their parent (parent-directed).</li>
<li>Parents can position their parent-directed children in a vertical stack, horizontal stack, or grid.</li>
<li>The same units—pixels, percentages (of the parent size), and stretch (akin to flex, proportionally dividing up available space)—are used everywhere, with minimum and maximum constraints as part of the unit.</li>
</ul>
</blockquote>
<p>At its most basic level, your layouts are just rows and columns of widgets, each of which may contain more rows and columns of widgets. Beyond that, sizes of your widgets can be pixels, a percentage of the parent, or stretch to fill. That's it. Stupid simple.</p>
<h2 id="how-do-i-use-it"><a class="header" href="#how-do-i-use-it">How do I use it?</a></h2>
<p>There are some primitive widgets that make the layout system easier to grok. <code>Column</code>, <code>Row</code>, <code>Grid</code>, <code>Padding</code>, and <code>Spacing</code>, each of which simply abstract out the layout. While you could use <code>ctx.set_layout</code> for each widget yourself, it's recommended to use these widgets instead, as it makes your widgets simpler and more reusable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state"><a class="header" href="#state">State</a></h1>
<p>Widgets may contain their own, self contained state, which persists across rebuilds (usually—more on that in a minute). Whenever the state changes, the widget's <code>build()</code> function will be re-invoked, and its children will be rebuilt. This is your main tool for implementing a user interface that can react to user events. Lets write up a quick counter example to demonstrate this:</p>
<pre><code class="language-rust noplaypen">// Requires the `HoverPlugin` for the `Button` to function properly, so
// make sure you call `ui.init_plugin(HoveringPlugin::default);`

<span class="boring">#[functional_widget]
</span>fn counter_widget(ctx: &amp;WidgetContext, font: FontId) -&gt; BuildResult {
    let num = ctx.use_state(|| 0);

    build! {
        Column {
            children: [
                Text::is(font, 32.0, format!(&quot;clicked: {} times&quot;, num.read())),
                Button {
                    child: Padding {
                        padding: Margin::All(10.0.into()),
                        child: Text::is(font, 32.0, &quot;A Button&quot;.into())
                    },
                    on_pressed: Callback::from(move |()| {
                        *num.write() += 1;
                    })
                }
            ]
        }
    }
}
</code></pre>
<p>Any time you use <code>num.write()</code>, it will cause any listening widgets to be rebuilt on the next update, so ensure you only call it when you <em>actually</em> change something. The first time <code>ctx.use_state(|| 0)</code> is used, the closure within the method is called to initialize the state. In this case, it will be initialized to zero. On subsequent rebuilds of the widget, the previous state that it was in will be persisted. However, this only applies if the parent of the widget is not rebuilt.</p>
<p>If you want to create state, but not listen to changes to it, you can instead use <code>ctx.init_state</code>. This is useful for widgets that manage state that children respond to, but state that itself doesn't react to. If you were to use that above, instead of <code>use_state</code>, the value would have changed internally, but you wouldn't see any change to the UI.</p>
<h2 id="globals"><a class="header" href="#globals">Globals</a></h2>
<p>A global acts much the same way as state, but it exists once in your application and is shared amongst all widgets, no matter how deep they are in your tree.</p>
<pre><code class="language-rust noplaypen"><span class="boring">#[functional_widget]
</span>fn widget_with_global(ctx: &amp;WidgetContext) -&gt; BuildResult {
    let state = ctx.use_global(|| 0);

    build! {
        Drawable {
            layout: Layout {
                sizing: Sizing::Set { width: 64.0, height 32.0 }
            }
        }
    }
}
</code></pre>
<p>In this case, <code>use_global</code> will fetch the global state or initialize it to zero if it does not already exist.</p>
<h2 id="parental-rebuilds"><a class="header" href="#parental-rebuilds">Parental Rebuilds</a></h2>
<p>When a widget is rebuilt, its state is persisted. However, any children it has will be reinitialized, meaning <em>their</em> state will be destroyed. This means you need to be careful in how you structure your interface to reduce rebuilds, and to work around this limitation. For more information on this, you can see <a href="usage/limiting-rebuilds.html">Limiting Rebuilds</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fonts"><a class="header" href="#fonts">Fonts</a></h1>
<p><code>agui</code> comes with a built-in font system, managed by the <code>Fonts</code> struct as a global. In order to render text, you must begin by loading the font into <code>agui</code>; this is because the layout system must know how large text will be before rendering. While each integration has their own methods for doing so, most of them should follow the same general convention. Using <code>agui_agpu</code> as an example, we just need to load the font file, or bytes:</p>
<pre><code class="language-rust noplaypen"><span class="boring">fn main() -&gt; Result&lt;(), agpu::BoxError&gt; {
</span><span class="boring">    let program = agpu::GpuProgram::builder(&quot;agui fonts&quot;)
</span><span class="boring">        // The integration requires a few GPU features to be enabled
</span><span class="boring">        .with_gpu_features(
</span><span class="boring">                Features::TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES
</span><span class="boring">                | Features::VERTEX_WRITABLE_STORAGE,
</span><span class="boring">        )
</span><span class="boring">        .build()?;
</span><span class="boring">
</span>    // Create a UI with the default render passes
    let mut ui = UI::with_default(&amp;program);

    // Import font bytes directly
    let font_id = ui.load_font_bytes(include_bytes!(&quot;./fonts/DejaVuSans.ttf&quot;));

    // Import a font file
    let font_id = ui.load_font_file(&quot;./fonts/DejaVuSans.ttf&quot;);
<span class="boring">}
</span></code></pre>
<p>The function returns a <code>FontId</code> which is used to reference the font in your UI. This can be stored however you like, and is generally used when creating <code>Text</code> widgets:</p>
<pre><code class="language-rust noplaypen">Text::is(font_id, 32.0, &quot;Hello, world!&quot;.into())
</code></pre>
<h2 id="supported-font-formats"><a class="header" href="#supported-font-formats">Supported Font Formats</a></h2>
<p>We use <code>glyph_brush</code> to handle laying out fonts/glyphs, which itself utilizes <code>ab_glyph</code>. Therefore, we support any font format they do. At the time of writing, <code>agui</code> only supports loading TTF fonts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clipping"><a class="header" href="#clipping">Clipping</a></h1>
<p>Clipping gets its own section because, while it's useful, it comes with some very important drawbacks. One thing to keep in mind is that child widgets are not clipped by default.</p>
<h2 id="motivation-and-usage"><a class="header" href="#motivation-and-usage">Motivation and Usage</a></h2>
<p>There are cases where a widget will want to <em>absolutely ensure</em> child widgets do not render outside of its bounds. Think a circular profile picture or a scroll area. In these cases, you need to set the clipping bounds of the widget using <code>ctx.set_clipping</code>. This function takes in a <code>Shape</code> and will instruct the renderer to ensure no children are drawn outside of those bounds.</p>
<pre><code class="language-rust noplaypen"><span class="boring">#[functional_widget]
</span>fn clipped_widget(ctx: &amp;WidgetContext, child: WidgetRef) -&gt; BuildResult {
    ctx.set_clipping(
        Shape::RoundedRect {
            top_left: 4.0,
            top_right: 4.0,
            bottom_right: 4.0,
            bottom_left: 4.0,
        }
        .into(),
    );

    child.into()
}
</code></pre>
<h2 id="consequences"><a class="header" href="#consequences">Consequences</a></h2>
<p>This is not a cheap operation, so care should be taken to ensure this is only used as <em>absolutely necessary</em>. Each widget that clips its children will cause a new render pass to be created (a non-negligable operation), which can add up quickly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyed-widgets"><a class="header" href="#keyed-widgets">Keyed Widgets</a></h1>
<p>Occasionally you'll run into a situation where you are <em>absolutely positive</em> that child widgets will not react to a parent rebuilding. In these cases, keyed widgets come to the rescue. However, they must be used carefully as they may cause logical inconsistencies or non-deterministic behavior if used incorrectly. Another way to think of them are as &quot;cache keys&quot; instead of just keys.</p>
<p>There are two <em>types</em> of keys, at the time of writing:</p>
<ul>
<li><strong>Local</strong>: These are scoped to the widget creating the key, and don't propagate down to children.</li>
<li><strong>Global</strong>: These are scoped to the entire application, meaning widgets can move around the tree in certain situations.</li>
</ul>
<p>There's also a third &quot;type&quot;, and that's unique keys (which are really just Global keys). These are explained in a bit more detail below.</p>
<h1 id="motivation-and-usage-1"><a class="header" href="#motivation-and-usage-1">Motivation and Usage</a></h1>
<p>Imagine a situation where you have a widget which only provides layout sizing to its children, and reacts to some global state to set that size. This is the exact situation for the <code>App</code> widget:</p>
<pre><code class="language-rust noplaypen">#[functional_widget]
fn app(ctx: &amp;WidgetContext, child: WidgetRef) -&gt; BuildResult {
    // Fetch the `AppSettings` global, which contains app sizing information
    let settings = ctx.use_global::&lt;AppSettings, _&gt;(AppSettings::default);

    let settings = settings.read();

    // Set the sizing of this widget, so children may take up the entirety of the app size
    ctx.set_layout(build! {
        Layout {
            sizing: Sizing::Axis {
                width: Units::Pixels(settings.width),
                height: Units::Pixels(settings.height),
            }
        }
    });

    // Return the child
    child.into()
}
</code></pre>
<p>In this case, this would cause child widgets to be rebuilt whenever the app size changes (think window resizing), incurring potentially expensive tree operations and absolute state loss of all children. In this case, we can guarantee that the widget rebuilding won't change the children in any way. <em>Given these guarantees</em>, we can use a Key. Simply change the last line to this:</p>
<pre><code class="language-rust noplaypen">// `Key::single()` is a helper alias of `Key::Local(0)`
ctx.key(Key::single(), child).into()
</code></pre>
<p>This will cause the child widget to be cached and reused when the parent <code>App</code> widget is rebuilt, instead of recreating it from scratch. The exact meaning of this line will be elaborated on in a moment.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Keys are limited in how they function, and it's important to understand these limitations to use them effectively.</p>
<p>Most notably, only one key with the same value may exist in any given scope. Two local keys with the same value may not exist in a single widget, but two separate widgets (even if one is a child of the other) may share exact values without issue. The same cannot be said for global keys, which must exist once in the entirety of your application. If you break this convention, your application <em>will</em> <code>panic!</code> if two keys clash during a rebuild.</p>
<p>Additionally, keys only function if the widget is removed and re-added to the tree within a single update. If you have a keyed widget that gets removed from the tree, but then gets added back into the tree in a subsequent <code>update()</code>, then it will be regenerated anew.</p>
<h2 id="local-keys"><a class="header" href="#local-keys">Local Keys</a></h2>
<p>Local keys are just as the name implies: they're local to the widget that defined them. If your widget can function using local keys, it's highly recommended to use them over any other since they come with the fewest strings attached.</p>
<pre><code class="language-rust noplaypen">Key::single() // If the widget only contains one keyed widget

// Otherwise, we use

Key::local(hashable_value)

// or

Key::Local(u64)
</code></pre>
<h2 id="global-keys"><a class="header" href="#global-keys">Global Keys</a></h2>
<p>Global keys, just like globals, can be used throughout the entirety of your application. They <strong>must</strong> follow the convention of each key being entirely unique to your application, and should not be used by third party widget crates. Third parties should use unique keys, or accept a key as a parameter.</p>
<pre><code class="language-rust noplaypen">Key::global(hashable_value)

// or

Key::Global(u64)
</code></pre>
<h3 id="unique-keys"><a class="header" href="#unique-keys">Unique Keys</a></h3>
<p>Unique keys are global keys, but they're designed to be passed as an argument to child widgets. These are non-deterministic, and a new one should be generated each time one is created, using <code>Key::unique()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computed-values"><a class="header" href="#computed-values">Computed Values</a></h1>
<p>Computed values are an extremely useful construct. They can listen to state and react to it, but will only cause the widget they're defined in to rebuild if their return value changes. Instead of implementing an event listener system, we use computed values to achieve the same effect.</p>
<h2 id="motivation-and-usage-2"><a class="header" href="#motivation-and-usage-2">Motivation and Usage</a></h2>
<p>Sometimes you'll want to listen to some state, but your widget will not always react or otherwise respond to that state change. In cases where this can be guaranteed (and deterministically tested against), we can use computed values to achieve this effect. To demonstrate them, we'll check if the user is currently hovering over the widget by utilizing the <code>HoverPlugin</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#[functional_widget]
</span>fn hovering_widget(ctx: &amp;WidgetContext) -&gt; BuildResult {
    let is_hovering = ctx.computed(|ctx| {
        // We use `try_use_global` here, since we don't want to test for hovering if the plugin isn't loaded
        if let Some(hovering) = ctx.try_use_global::&lt;Hovering&gt;() {
            if hovering.read().is_hovering(ctx) {
                true
            }
        }

        false
    });

    build! {
        if is_hovering {
            Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 64.0, height 32.0 }
                }
            }
        }else{
            Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 32.0, height 64.0 }
                }
            }
        }
    }
}
</code></pre>
<p>In this case, the computed value's closure will be called whenever the <code>Hovering</code> global is updated, but will only mark the widget for rebuild when it returns a different value. In this case, it will only rebuild when it goes from a non-hover state to a hover state and vice versa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limiting-rebuilds"><a class="header" href="#limiting-rebuilds">Limiting Rebuilds</a></h1>
<p>Rebuilds are at the heart of how <code>agui</code> works. Whenever state changes, the widgets in the tree that may change are updated. However, this is a very naïve system and much of the responsibility for limiting these rebuilds is up to the developer (you). We'll go over the problem, and devise a few solutions for it, however ultimately the decision is up to you.</p>
<h2 id="builders"><a class="header" href="#builders">Builders</a></h2>
<p>Builders are essentially closure-derived widgets. You can create these ad-hoc to limit the scope of rebuilds to a sub-tree of widgets, because they're essentially parent-widgets themselves with their own <code>WidgetContext</code>.</p>
<pre><code class="language-rust noplaypen"><span class="boring">#[functional_widget]
</span>fn widget_with_builder(ctx: &amp;WidgetContext) -&gt; BuildResult {
    build! {
        Builder::new(move |ctx| {
            // `ctx` is a new `WidgetContext` which will not affect the parent widget

            let state = ctx.use_state(|| 0);

            build! {
                Drawable {
                    layout: Layout {
                        sizing: Sizing::Set { width: 64.0, height 32.0 }
                    }
                }
            }
        }
    }
}
</code></pre>
<h2 id="globals-1"><a class="header" href="#globals-1">Globals</a></h2>
<p>Another option is utilizing globals.  You can create state, then create sub-widgets which listen to that state, resulting in potentially fewer rebuilds of your application with little effort. However, this has the effect of making it difficult to grok exactly what your application is doing if used incorrectly, and potentially makes limiting the scope of rebuilds more troublesome as your application grows. <a href="usage/state.html">You can read more about it here.</a></p>
<h2 id="providers-and-consumers"><a class="header" href="#providers-and-consumers">Providers and Consumers</a></h2>
<p>Instead of globals, you can use <a href="usage/../plugins/providers_and_consumers.html">Providers</a>. This is an optional plugin which makes state available to its subtree of widgets, however it's not free. Whenever a child needs to access the state, it needs to traverse the tree to find a parent which is providing that state. This is <em>often</em> negligable, but as your application grows it may become more pronounced if the children that use the state are deeper in the tree.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="providers--consumers"><a class="header" href="#providers--consumers">Providers &amp; Consumers</a></h1>
<p>The provider pattern can provide <em>(hah!)</em> some much needed structure to your state. That's why <code>agui</code> provides <em>(hah)</em> this plugin in <code>agui_widgets</code>, to provide <em>(hah—okay, I'll stop)</em> some standardization to this extremely useful pattern.</p>
<h2 id="motivation-and-usage-3"><a class="header" href="#motivation-and-usage-3">Motivation and Usage</a></h2>
<p>As your application grows, using globals can get messy. It becomes increasingly difficult to understand where state is mutated, and what widgets are listening to said state. It also makes your code significantly less reusable. In contrast to widget state or globals, the provider pattern acts as the middleground between these two possibilities: it makes state available <em>only to children</em> of a widget, rather than to the entirety of the widget tree.</p>
<p>A perfect example of where this pattern shines is in the <code>Theme</code> plugin, of which we cover in more detail <a href="plugins/./themes.html">in this section</a>. Themes are generally &quot;global&quot; (in the sense that you want everything to look the same), but sometimes you want the style of your widgets to be different in a certain part of your application. The widgets <code>agui</code> provides use the <code>Theme</code> plugin extensively, making it simple for you to style your application however you desire.</p>
<h3 id="providing-state"><a class="header" href="#providing-state">Providing State</a></h3>
<p>To provide some state, we just need to provide it somewhere in the widget tree:</p>
<pre><code class="language-rust noplaypen">use agui::widgets::plugins::provider::ProviderExt;

<span class="boring">#[functional_widget]
</span>fn provider_widget(ctx: &amp;WidgetContext, child: WidgetRef) -&gt; BuildResult {
    // The generic isn't required, here; it's just used for clarity.
    let some_number = ctx.use_state::&lt;usize, _&gt;(|| 0);

    // `ProviderExt` gives an easy-to-use extension trait onto `Notify` (which is what `use_state` and `init_state` return).
    some_number.provide(ctx);

    // This child, and all children within it, will now have access to `some_number`, as long as they Consume it properly.
    child.into()
}
</code></pre>
<h3 id="consuming-state"><a class="header" href="#consuming-state">Consuming State</a></h3>
<p>Consuming from a provided state is also extremely simple; the main difference in usage between this pattern and globals is that <code>use_global</code> will init non-existent values, but the Provider pattern will return <code>None</code> if it doesn't exist in the tree.</p>
<pre><code class="language-rust noplaypen">use agui::widgets::plugins::provider::ConsumerExt;

<span class="boring">#[functional_widget]
</span>fn provider_widget(ctx: &amp;WidgetContext, child: WidgetRef) -&gt; BuildResult {
    // This will be ignored by `ctx.consume` since it's not provided.
    let some_number = ctx.use_state::&lt;usize, _&gt;(|| 0);

    // `ConsumerExt` gives an easy-to-use extension trait onto `WidgetContext`.
    if let Some(some_number) = ctx.consume::&lt;usize&gt;() {
        // Use `some_number`, here.
    }

    BuildResult::None
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hovering"><a class="header" href="#hovering">Hovering</a></h1>
<p>The <code>HoverPlugin</code> listens to the <code>Mouse</code> global, detecting what widgets the mouse is currently hovering over. This can be used for animations, click detection, and in many other scenarios where mouse interaction is required.</p>
<h2 id="motivation-and-usage-4"><a class="header" href="#motivation-and-usage-4">Motivation and Usage</a></h2>
<p>Without user interaction, a user interface isn't exactly, well, a user interface. There's also great value in reducing exact mouse position events into a single listener that can then &quot;broadcast&quot; coarser events to any widget that cares about them. Imagine if every button in your widget tree was getting updated every single time the mouse position changed—it would cause an unfortunate amount of update calls for an event that, realistically, doesn't need to be that fine-grained.</p>
<p>So, the <code>HoverPlugin</code> solves that problem. It consumes mouse positions and writes to the <code>Hovering</code> global only when the widget you're hovering over changes, saving CPU and reducing the errors that could occur if every widget was implementing this functionality themselves.</p>
<p>To use it, it's highly recommended to listen to it within a computed value, so your widget is only rebuilt when its hover state changes.</p>
<pre><code class="language-rust noplaypen"><span class="boring">#[functional_widget]
</span>fn hovering_widget(ctx: &amp;WidgetContext) -&gt; BuildResult {
    let is_hovering = ctx.computed(|ctx| {
        // We use `try_use_global` here, since we don't want to test for hovering if the plugin isn't loaded
        if let Some(hovering) = ctx.try_use_global::&lt;Hovering&gt;() {
            if hovering.read().is_hovering(ctx) {
                true
            }
        }

        false
    });

    build! {
        if is_hovering {
            Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 64.0, height 32.0 }
                }
            }
        }else{
            Drawable {
                layout: Layout {
                    sizing: Sizing::Set { width: 32.0, height 64.0 }
                }
            }
        }
    }
}
</code></pre>
<p>No matter how often the <code>Hovering</code> global changes, the widget will only be rebuilt when <code>is_hovering</code> matches and the function returns <code>true</code>. If you didn't use the computed value, the widget would be rebuilt every time the currently hovered widget changed, which wouldn't be good.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animations"><a class="header" href="#animations">Animations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-your-own"><a class="header" href="#writing-your-own">Writing your Own</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitives-1"><a class="header" href="#primitives-1">Primitives</a></h1>
<p>Primitive widgets are the most basic widgets that exist; they are generally unchanging and very unopinionated. Virtually every project that utilizes <code>agui</code> will use these as their most basic, most stable widgets.</p>
<h2 id="layout-1"><a class="header" href="#layout-1">Layout</a></h2>
<p>There are various widgets designed to abstract the layout to make their behavior clearer. It's recommended to use them whenever possible, so design and functionality are standardized both within your application and within all <code>agui</code> applications.</p>
<h3 id="basics"><a class="header" href="#basics">Basics</a></h3>
<ul>
<li><strong>Column</strong>: A column stacks child widgets vertically, with an optional <code>spacing</code>.</li>
<li><strong>Row</strong>: A row lines up child widgets horizontally, with an optional <code>spacing</code>.</li>
<li><strong>Padding</strong>: Creates a widget with <code>margin</code>, effectively creating an internal padding in the widget.</li>
</ul>
<h3 id="spacing"><a class="header" href="#spacing">Spacing</a></h3>
<p>The <code>Spacing</code> widget is another useful helper which can be used to create arbitrary distance between two widgets by utilizing its helper functions.</p>
<pre><code class="language-rust noplaypen">Spacing::none() // Creates the widget with null spacing.

Spacing::horizontal(Units) // Creates a widget with `Units` width.

Spacing::vertical(Units) // Creates a widget with `Units` height.
</code></pre>
<h2 id="drawable"><a class="header" href="#drawable">Drawable</a></h2>
<p>These lie at the heart of the rendering system. Every integration is required to implement this, and every widget is heavily encouraged to utilize this widget whenever drawing something on screen.</p>
<h3 id="what-if-i-dont-want-to-use-it"><a class="header" href="#what-if-i-dont-want-to-use-it">What if I don't want to use it?</a></h3>
<p>Well, then your life just got a lot more complicated. Widgets that don't wish to use <code>Drawable</code> must implement their own renderer in the integration they're using. See your integration's respective docs to see how to do this.</p>
<h2 id="text"><a class="header" href="#text">Text</a></h2>
<p>Just like <code>Drawable</code>, this is how you tell the renderer to draw Text in your interface. Its default functionality is slightly different from other widgets, so it's important to note here: by default, this widget will set its size to the width of the text as rendered. If you want it to take up less space, ensure you set its <code>sizing</code> field.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets-1"><a class="header" href="#widgets-1">Widgets</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app"><a class="header" href="#app">App</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="button"><a class="header" href="#button">Button</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="globals-2"><a class="header" href="#globals-2">Globals</a></h1>
<p><code>agui</code> includes some default application globals to standardize some common functionality. This includes <code>Mouse</code>, <code>Keyboard</code>, <code>Theme</code>, among other things we'll go over in the next few sections.</p>
<h2 id="who-implements-these"><a class="header" href="#who-implements-these">Who implements these?</a></h2>
<p>When building an integration for new renderer, including some of the systems necessary to update these globals is largely non-negotiable. <code>agui</code> has no way to know how to update <code>Mouse</code> or <code>Keyboard</code> state, as the core doesn't implement a windowing system, so this is left entirely to the integrations. It's unnecessary to go much deeper in this section, but will be covered later. Rest assured the functionality is standardized across integrations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mouse"><a class="header" href="#mouse">Mouse</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keyboard"><a class="header" href="#keyboard">Keyboard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="themes"><a class="header" href="#themes">Themes</a></h1>
<p>Having a standardized Theme system is necessary for an easy-to-use system. However, we don't use a single struct for styles, as this is wasteful and cannot cover every use case. Instead, each widget should create a struct with style information, that derives the traits: <code>Default + Send + Sync</code>.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Lets go over how a button handles its styling, as an example:</p>
<pre><code class="language-rust noplaypen">#[derive(Clone)]
pub struct ButtonStyle {
    pub normal: DrawableStyle,
    pub hover: DrawableStyle,
    pub pressed: DrawableStyle,
}

impl Default for ButtonStyle {
    fn default() -&gt; Self {
        Self {
            normal: DrawableStyle {
                color: Color::White,
                opacity: 1.0,
            },

            hover: DrawableStyle {
                color: Color::LightGray,
                opacity: 1.0,
            },

            pressed: DrawableStyle {
                color: Color::DarkGray,
                opacity: 1.0,
            },
        }
    }
}
</code></pre>
<p>This houses all of the fields that the <code>Button</code> widget uses to determine how it will render. When it actually wants to utilize that style, we use the <code>StyleExt</code> extension trait.</p>
<pre><code class="language-rust noplaypen">use agui::widgets::state::theme::StyleExt;

<span class="boring">#[functional_widget]
</span>fn button(ctx: &amp;WidgetContext, style: Option&lt;ButtonStyle&gt;, child: WidgetRef) -&gt; BuildResult {
    // `resolve` will perform the following steps to get the style:
    //   1. If the style is `Some`, return it
    //   2. Check for a widget that's providing a Theme, and get_or_default from that
    //   3. Check global state for a Theme, and get_or_default from that
    //   4. Use the Default style
    let style: ButtonStyle = self.style.resolve(ctx);

    BuildResult::None
}
</code></pre>
<p>Notice that the <code>style</code> field is an <code>Option</code>. The <code>StyleExt</code> trait also supports this type, making it simple to allow style overrides without additional checks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-they-work"><a class="header" href="#how-they-work">How they work</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-your-own-1"><a class="header" href="#writing-your-own-1">Writing your own</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guarantees"><a class="header" href="#guarantees">Guarantees</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layers"><a class="header" href="#layers">Layers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="title-screen"><a class="header" href="#title-screen">Title Screen</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings"><a class="header" href="#settings">Settings</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-view"><a class="header" href="#scroll-view">Scroll View</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
